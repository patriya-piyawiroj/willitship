// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title BillOfLading
 * @notice BillOfLading contract for managing a single bill-of-lading trade finance transaction
 * @dev One BillOfLading contract per BoL, deployed by BillOfLadingFactory
 */
contract BillOfLading is ERC721, Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;
    
    // Trade state structure
    struct TradeState {
        bytes32 bolHash;
        address buyer;
        address seller;
        address stablecoin;
        uint256 declaredValue;
        uint256 totalFunded;
        uint256 totalRepaid;
        bool settled;
        bool claimsIssued;
        bool fundingEnabled;
        bool nftMinted;
    }
    
    // Claim token contract
    ClaimToken public claimToken;
    
    // Trade state
    TradeState public tradeState;
    
    // BoL number (stored as string)
    string public blNumber;
    
    // BoL NFT token ID (always 1, since we only mint one)
    uint256 public constant BOL_TOKEN_ID = 1;
    
    // Events
    event Created(address indexed buyer, address indexed seller, uint256 declaredValue, string blNumber);
    event Active();
    event Funded(address indexed investor, uint256 amount, uint256 claimTokens);
    event Full();
    event Inactive();
    event Paid(address indexed buyer, uint256 amount);
    event Claimed(address indexed holder, uint256 amount, uint256 claimTokensBurned);
    event Settled();
    
    /**
     * @notice Initialize a new BillOfLading contract
     * @param bolHash The hash of the bill-of-lading
     * @param seller The seller's address (shipper)
     * @param buyer The buyer's address
     * @param declaredValue The declared value of the trade
     * @param _blNumber The bill of lading number
     */
    constructor(
        bytes32 bolHash,
        address seller,
        address buyer,
        uint256 declaredValue,
        string memory _blNumber
    ) ERC721("Bill of Lading", "BOL") Ownable(msg.sender) {
        require(seller != address(0), "BillOfLading: seller cannot be zero address");
        require(buyer != address(0), "BillOfLading: buyer cannot be zero address");
        require(declaredValue > 0, "BillOfLading: declared value must be greater than zero");
        
        tradeState = TradeState({
            bolHash: bolHash,
            buyer: buyer,
            seller: seller,
            stablecoin: address(0), // Will be set later
            declaredValue: declaredValue,
            totalFunded: 0,
            totalRepaid: 0,
            settled: false,
            claimsIssued: false,
            fundingEnabled: false,
            nftMinted: false
        });
        
        // Store blNumber
        blNumber = _blNumber;
        
        // Deploy the claim token contract
        claimToken = new ClaimToken(address(this), declaredValue);
    }
    
    /**
     * @notice Set the stablecoin address (can only be called once)
     * @param stablecoin The address of the stablecoin token contract
     */
    function setStablecoin(address stablecoin) external onlyOwner {
        require(tradeState.stablecoin == address(0), "BillOfLading: stablecoin already set");
        require(stablecoin != address(0), "BillOfLading: stablecoin cannot be zero address");
        tradeState.stablecoin = stablecoin;
    }
    
    /**
     * @notice Mint the BoL NFT (can only be called once)
     * @param buyer The buyer's address
     * @param seller The seller's address
     * @param declaredValue The declared value
     */
    function mint(address buyer, address seller, uint256 declaredValue) external {
        require(!tradeState.nftMinted, "BillOfLading: NFT already minted");
        require(buyer == tradeState.buyer, "BillOfLading: buyer mismatch");
        require(seller == tradeState.seller, "BillOfLading: seller mismatch");
        require(declaredValue == tradeState.declaredValue, "BillOfLading: declaredValue mismatch");
        require(tradeState.stablecoin != address(0), "BillOfLading: stablecoin not set");
        
        // Mint the BoL NFT to this contract (owned by BillOfLading contract)
        _mint(address(this), BOL_TOKEN_ID);
        
        tradeState.nftMinted = true;
        
        emit Created(buyer, seller, declaredValue, blNumber);
    }
    
    /**
     * @notice Issue claim tokens and enable funding (can only be called once)
     * @dev Enables funding and emits "Active" event
     */
    function issueClaims() external {
        require(tradeState.nftMinted, "BillOfLading: NFT must be minted first");
        require(!tradeState.claimsIssued, "BillOfLading: claims already issued");
        require(!tradeState.settled, "BillOfLading: trade is settled");
        
        tradeState.claimsIssued = true;
        tradeState.fundingEnabled = true;
        
        emit Active();
    }
    
    /**
     * @notice Fund the trade (called by investor/bank)
     * @param amount The amount of stablecoin to fund
     */
    function fund(uint256 amount) external nonReentrant {
        require(tradeState.fundingEnabled, "BillOfLading: funding not enabled");
        require(!tradeState.settled, "BillOfLading: trade is settled");
        require(
            tradeState.totalFunded + amount <= tradeState.declaredValue,
            "BillOfLading: funding exceeds declared value"
        );
        require(amount > 0, "BillOfLading: amount must be greater than zero");
        require(tradeState.stablecoin != address(0), "BillOfLading: stablecoin not set");
        
        IERC20 stablecoin = IERC20(tradeState.stablecoin);
        
        // Transfer stablecoin from investor to seller
        stablecoin.safeTransferFrom(msg.sender, tradeState.seller, amount);
        
        // Mint claim tokens to investor (1:1 ratio with stablecoin)
        claimToken.mint(msg.sender, amount);
        
        tradeState.totalFunded += amount;
        
        emit Funded(msg.sender, amount, amount);
        
        // Check if fully funded
        if (tradeState.totalFunded == tradeState.declaredValue) {
            emit Full();
        }
    }
    
    /**
     * @notice Surrender the trade (disables funding)
     * @dev Disables funding and emits "Inactive" event
     * @notice Only the buyer can surrender the trade
     */
    function surrender() external {
        require(msg.sender == tradeState.buyer, "BillOfLading: only buyer can surrender");
        require(tradeState.fundingEnabled, "BillOfLading: funding is not enabled");
        require(!tradeState.settled, "BillOfLading: trade is settled");
        
        tradeState.fundingEnabled = false;
        
        emit Inactive();
    }
    
    /**
     * @notice Pay stablecoin to escrow (called by buyer)
     * @param amount The amount of stablecoin to pay
     */
    function pay(uint256 amount) external nonReentrant {
        require(msg.sender == tradeState.buyer, "BillOfLading: only buyer can pay");
        require(!tradeState.settled, "BillOfLading: trade is settled");
        require(amount > 0, "BillOfLading: amount must be greater than zero");
        require(tradeState.stablecoin != address(0), "BillOfLading: stablecoin not set");
        
        IERC20 stablecoin = IERC20(tradeState.stablecoin);
        
        // Transfer stablecoin from buyer to this contract (escrow)
        stablecoin.safeTransferFrom(msg.sender, address(this), amount);
        
        tradeState.totalRepaid += amount;
        
        emit Paid(msg.sender, amount);
    }
    
    /**
     * @notice Redeem claim tokens for stablecoin (called by claim holder)
     * @dev Transfers money to claim token owner from contract and emits "Claimed"
     * When all tokens have been claimed, calls _settle which burns the NFT and emits "Settled"
     */
    function redeem() external nonReentrant {
        require(!tradeState.settled, "BillOfLading: trade is settled");
        require(tradeState.totalRepaid > 0, "BillOfLading: no repayments available");
        require(tradeState.stablecoin != address(0), "BillOfLading: stablecoin not set");
        
        uint256 holderBalance = claimToken.balanceOf(msg.sender);
        require(holderBalance > 0, "BillOfLading: no claim tokens to redeem");
        
        uint256 totalSupply = claimToken.totalSupply();
        require(totalSupply > 0, "BillOfLading: no claim tokens in circulation");
        
        // Calculate redeemable share: (holder_balance / total_supply) * total_repaid - already_redeemed
        uint256 redeemableShare = (holderBalance * tradeState.totalRepaid) / totalSupply;
        uint256 alreadyRedeemed = redeemedAmounts[msg.sender];
        uint256 redeemableAmount = redeemableShare > alreadyRedeemed 
            ? redeemableShare - alreadyRedeemed 
            : 0;
        
        require(redeemableAmount > 0, "BillOfLading: nothing to redeem");
        
        // Update redeemed tracking
        redeemedAmounts[msg.sender] = redeemableShare;
        
        // Transfer stablecoin from escrow to holder
        IERC20 stablecoin = IERC20(tradeState.stablecoin);
        stablecoin.safeTransfer(msg.sender, redeemableAmount);
        
        // Burn claim tokens equal to redeemed amount
        claimToken.burn(msg.sender, redeemableAmount);
        
        emit Claimed(msg.sender, redeemableAmount, redeemableAmount);
        
        // Check if all claim tokens are burned
        if (claimToken.totalSupply() == 0) {
            _settle();
        }
    }
    
    /**
     * @notice Internal function to settle the trade
     * @dev Burns the BoL NFT and marks trade as settled, emits "Settled" event
     */
    function _settle() internal {
        require(!tradeState.settled, "BillOfLading: already settled");
        
        tradeState.settled = true;
        
        // Burn the BoL NFT
        _burn(BOL_TOKEN_ID);
        
        emit Settled();
    }
    
    // Mapping to track redeemed amounts per claim holder
    mapping(address => uint256) public redeemedAmounts;
    
    /**
     * @notice Get the current state of the trade
     * @return state The trade state struct
     */
    function getTradeState() external view returns (TradeState memory state) {
        return tradeState;
    }
    
    // Note: The BoL NFT is owned by this contract and will not be transferred
    // since the contract is the owner. When settled, it is burned via _burn().
}

/**
 * @title ClaimToken
 * @notice ERC20 token representing claims on a trade
 * @dev Fixed supply equal to declared value, minted during funding, burned during redemption
 */
contract ClaimToken is ERC20, Ownable {
    uint256 public immutable maxSupply;
    
    constructor(address billOfLadingContract, uint256 _maxSupply) ERC20("Trade Claim Token", "CLAIM") Ownable(billOfLadingContract) {
        maxSupply = _maxSupply;
    }
    
    /**
     * @notice Mint claim tokens (only callable by BillOfLading contract)
     * @param to Address to mint tokens to
     * @param amount Amount to mint
     */
    function mint(address to, uint256 amount) external onlyOwner {
        require(totalSupply() + amount <= maxSupply, "ClaimToken: exceeds max supply");
        _mint(to, amount);
    }
    
    /**
     * @notice Burn claim tokens (only callable by BillOfLading contract)
     * @param from Address to burn tokens from
     * @param amount Amount to burn
     */
    function burn(address from, uint256 amount) external onlyOwner {
        _burn(from, amount);
    }
}
